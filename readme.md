# Honeypot Project README - BluePigeon

BluePigeon Honeypot project.

Made by:

- Luka Vashakmadze
- Redas Musnikas
- Pedro Almeida Romano

# Introduction

This honeypot project consists of two main parts: the secure component, known as "BluePigeon," and the honeypot component designed to lure and engage potential attackers. BluePigeon is a simple blogging website built using HTML, CSS, and JavaScript for the front-end, and Express as the backend.

It integrates Firebase for authentication and database functionality. The secure website has an admin panel, also integrated with Firebase, where administrators can manage active users and their account statuses.

The second part is the "honeypot", which is the fake admin panel supposedly managing users of BluePigeon. It is written in php and uses mysql database along with honeytokens.

### **Possible commands:**

- pm2 status - to see status of express servers
- pm2 start - to start the servers
- sudo mariadb -u root -p - with the password 'root'

### **Local MariaDB:**

The unsecure parts of the project (honeypots) use locally run MariaDB. Here are is some information about it.

#### **Config:**

host = 'localhost';

username = 'root';

password = 'root';

database = 'users';

#### **Tables:**

- users - contains all the users with the columns(name(varchar), email(varchar), logged(int), status(int))
- adminuser - contains adminuser for the loginpage with the columns(username(varchar), password(varchaer)). This table contains only one entry which is the login info provided in the challenge 1.

# Components

1.  **BluePigeon (Secure Part):**

    The secure component, BluePigeon, serves as the genuine and secure section of the project. It is focused on providing a reliable and user-friendly blogging platform. BluePigeon is built using industry-standard technologies and adheres to security best practices.

    - **Front-End**: BluePigeon is a web-based blogging website constructed using HTML, CSS, and vanilla JavaScript for the client-side user interface. **Runs on port : 80**
    - **Back-End**: The server is powered by Express, a Node.js web application framework, handling data processing and business logic. **Runs on port : 3000**
    - **Authentication**: Firebase is used for email and password-based user authentication.
      Database: Firebase Database is employed to store website content and user data.
    - **Security**: To access and modify the database, BluePigeon utilizes JWT (JSON Web Token) tokens generated by Firebase, ensuring secure user interactions.

2.  **BluePigeon (Secure Part) Admin Panel:**

    This secure component, BluePigeon Admin Panel, serves as the genuine and secure admin section of the project. It is focused on providing a reliable and user-friendly Adminpanel for BluePigeon.

    - **Front-End**: BluePigeon AdminPanel is a web-based adminpanel constructed using HTML, CSS, and vanilla JavaScript for the client-side user interface. **Runs on port : 90**
    - **Authentication**: It has nginx basic authentication with these login info:

      **Username:** killerb

      **Password:** dertoxiccrafterpepe2122miskamusnikas

    - **Security**: To access and modify the database, It utilizes JWT (JSON Web Token) tokens generated by Firebase, ensuring secure user interactions.

3.  **Fake Admin Panel Honeypot:**

    The honeypot component is strategically designed to divert the attention of potential attackers.
    **Runs on port : 100**.
    It aims to engage them through various challenges and provide insights into their methods. The honeypot comprises:

    - **Objective**: The honeypot component is an intriguing diversion for potential attackers, designed to draw their focus away from the secure admin panel system.
    - **Challenge 1: SQL Injection**:
      To get access to the fake admin panel, attackers first have to bypass fake admin panel with sql injection. Blind SQL Injection: Attackers are challenged to bypass the login panel through intermediate SQL injection techniques. They must craft blind SQL queries that manipulate the database to gain unauthorized access. After gaining access user gets redirected to the page which sends email to us (honeytoken) and gets redirected back to the honeypot's next stage.

      For Example:
      `' OR IF(ASCII(SUBSTRING((SELECT username FROM users LIMIT 1), [1], 1)) = [102], SLEEP(5), 0) --`

      Normal SQLi:
      `'OR 1=1-- `

      Credentials: Username - naruto, Password - minato

    - **Challenge 2: Stored XSS Attack**:
      After they access the fake admin panel they have access to multiple functions like adding, removing users and modifying their fields in mysql database. With the input field they can add user and do Stored XSS Attack.

      For Example: ` <img src=x onerror=alert(1)>`

    - **Challenge 3: Broken Access to data**:
      Attackers can access a honeypot cookie containing a URL. When this URL in base64. Attacker has to decode base64 and they will be greeted with endpoint. When the endpoint is accessed, it initiates the automatic download of a fake user data Excel file. This action notifies admin via gmail when the file is opened, because it is a honeytoken excel file.

# Honeytokens

We use HoneyTokens to send alerts to us whenever the user completes different stages. With this, we get real-time updates to our email without needing to look at Kibana or Logs.

- **HoneyToken 1: Redirect Token**

  First HoneyToken gets initialized when user completes the first challenge (sqli) and gets access to fake admin panel. This is a redirect token and follows this sequence:

  1. User cracks the challenge
  2. User gets redirected to an url
  3. URL sends the email to us
  4. User gets redirected to the admin panel

- **HoneyToken 2: Excel File**

  Second HoneyToken gets initialized when the user complets the third challenge and gets access to Excel file that contains fake data. This excel file is actually a HoneyToken in disguise and follows this sequence:

  1. User cracks the challenge
  2. User opens the Excel File
  3. Excel file sends the email to us in the background

# Custom Logs

To see the POST and GET request logs we defined custom log in the main NGINX config file where we pass request body .

`
log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for" "$request_body"';`
